#!perl6

use v6;

$*ERR.print();

use CGI;
use HTML::Template;

class Wiki {

    my $.content_path        is rw;
    # RAKUDO: For some reason, the addition of a second class attribute makes
    # rakudo hang. Haven't been able to find out why. A simple -e program with
    # two class attrs runs fine.
#    my  $.modifications_path is rw;
    my $.template_path       is rw;
    my $.userfile_path       is rw;
    my $.sessionfile_path    is rw;
    my $.sessions            is rw;

    has $.cgi                is rw;
    #has $.sessions;
    my $.recent_changes_path is rw;

    method init {
        # RAKUDO: us from setting the attributes when declaring them
        $.content_path = 'data/articles/';
#        $.modifications_path = 'data/modifications/';
 
        # Trust us, this is required, at least it was when we put it in
        $*ERR.print();
        

        $.template_path = 'skin/';
        $.userfile_path = 'data/users';
        $.sessionfile_path = 'data/sessions';
        $.recent_changes_path = 'data/recent-changes';
        #$.sessions = %sessions;
    }

    method handle_request(CGI $cgi) {
        $.cgi = $cgi;

        # TODO: Implement $.cgi.path_info()
#        my $path = $.cgi.path_info();
#        if ( $path eq '/spartan.css' ) {
#            print read_file('skin/spartan.css');
#            return;
#        }

        my $action = $cgi.param<action> // 'view';

        # Need to move this line somewhere
        $*ERR.print();
        # RAKUDO: 'when' doesn't work properly yet
        my $handled = False;
        given $action {
            when 'view'    { self.view_page(); $handled = True }
            when 'edit'    { self.edit_page(); $handled = True }
            when 'log_in'  { self.log_in();    $handled = True }
            when 'log_out' { self.log_out();   $handled = True }
        }

        self.not_found() if !$handled;
    }

    method view_page() {
        my $page = $.cgi.param<page> // 'Main_Page';

        $*ERR.print();
        if !self.exists_wiki_page($page) {
            my $template = HTML::Template.new(
                filename => $.template_path ~ 'not_found.tmpl');

            $template.param('PAGE' => $page);

            $.cgi.send_response(
                $template.output(),
            );
            return;
        }

        my $template = HTML::Template.new(
            filename => $.template_path ~ 'view.tmpl');

        $template.param('TITLE' => $page);
        $template.param('CONTENT' => self.format_html(self.read_page($page)));

        $.cgi.send_response(
            $template.output(),
        );
    }

    method edit_page() {
        my $page = $.cgi.param<page> // 'Main_Page';

        my $sessions = self.read_sessions();

        my $session_id = $.cgi.cookie<session_id>;
        if !$session_id || !$sessions{$session_id} {
            return self.not_authorized();
        }

        my $already_exists
                        = self.wiki_page_exists($page);
        my $action      = $already_exists ?? 'Editing' !! 'Creating';
        my $old_content = $already_exists ?? self.read_page($page) !! '';
        my $title = "$action $page";

        # The 'edit' action handles both showing the form and accepting the
        # POST data. The difference is the presence of the 'articletext'
        # parameter -- if there is one, the action is considered a save.
        if $.cgi.param<articletext> {
            my $new_text = $.cgi.param<articletext>;
            my $author = $sessions{$session_id}<user_name>;
            self.modify_page($page, $new_text, $author);
            return self.view_page();
        }

        my $template = HTML::Template.new(
            filename => $.template_path ~ 'edit.tmpl');

        $template.param('PAGE'    => $page);
        $template.param('TITLE'   => $title);
        $template.param('CONTENT' => $old_content);

        $.cgi.send_response(
            $template.output(),
        );
    }

    method not_authorized() {
        my $template = HTML::Template.new(
            filename => $.template_path ~ 'action_not_authorized.tmpl');

        $template.param(DISALLOWED_ACTION => 'edit pages');

        $.cgi.send_response(
            $template.output(),
        );

        return;
    }

    method wiki_page_exists($page) {
        return file_exists($.content_path ~ $page );
    }

    method read_page_history($page) {
        my $file = $.content_path ~ $page;
        return [] unless file_exists( $file );
        my $page_history = eval( slurp($file) );
        return $page_history;
    }

    method read_page($page) {
        my $page_history = self.read_page_history($page);
        return "" unless $page_history;
        my $latest_change = self.read_modification( $page_history.shift );
        return $latest_change[1];
    }

    method modify_page($page, $new_text, $author) {
        my $modification_id = get_unique_id();

        my $page_history = self.read_page_history($page);
        $page_history.unshift( $modification_id );
        self.write_page_history( $page, $page_history );

        self.write_modification( $modification_id, 
            [ $page, $new_text, $author] );

        self.add_recent_change( $modification_id );
    }

    method read_recent_changes {
        return [] unless file_exists( $.recent_changes_path );
        return eval( slurp( $.recent_changes_path ) );
    }

    method write_recent_changes ( $recent_changes ) {
        my $fh = open($.recent_changes_path, :w);
        $fh.say($recent_changes.perl);
        $fh.close;
    }

    method add_recent_change( $modification_id ) {
        my $recent_changes = self.read_recent_changes();
        $recent_changes.unshift($modification_id);
        self.write_recent_changes( $recent_changes );
    }

    method write_page_history( $page, $page_history ) {
        my $file = $.content_path ~ $page;
        my $fh = open($file, :w);
        $fh.say($page_history.perl);
        $fh.close;
    }

    method write_modification ( $modification_id, $modification ) {

        my $file = 'data/modifications/' ~ $modification_id;
        my $fh = open( $file, :w );
        $fh.say($modification.perl);
        $fh.close();
    }

    method read_modification($modification_id) {

        # RAKUDO: Had to inline this class variable because it wouldn't work
        # otherwise.
        my $file = 'data/modifications/' ~ $modification_id;
        # RAKUDO: use :e
        return [] unless file_exists( $file );
        return eval( slurp($file) );
    }

    method read_users {
        # RAKUDO: use :e
        return {} unless file_exists( $.userfile_path );
        return eval( slurp( $.userfile_path ) );
    }

    method quote($metachar) {
        # RAKUDO: Tried chained trinary. Saw the result and cried.
        return '&#039;' if $metachar eq '\'';
        return '&lt;'   if $metachar eq '<';
        return '&gt;'   if $metachar eq '>';
        return '&amp;'  if $metachar eq '&';
        return $metachar;
    }

    method format_html($text is rw) {
        # RAKUDO: When 'gather' is implemented, we can to this a bit nicer with
        # `join '', gather { ... }` instead.
        my $result = '';
        if $text ~~ Wiki::Syntax::TOP {
            # RAKDUO: Must match again. [perl #57858]
            $text ~~ Wiki::Syntax::TOP;
            for $/<paragraph> -> $p {

                $result ~= '<p>';
                for $p<parchunk> {
                    my $text = $_.values[0];
                    given $_.keys[0] {
                        when 'twext'     { $result ~= $text }
                        when 'wikimark'  { my $page = substr($text, 2, -2);
                                           $result ~= self.make_link($page) }
                        when 'metachar'  { $result ~= self.quote($text) }
                        when 'malformed' { $result ~= $text }
                    }
                 }
                 $result ~= "</p>\n";
            }
        } else {
            $result = '<p>Could not parse...</p>';
        }
        return $result;
    }

    method make_link($page) {
        if self.exists_wiki_page($page) {
            return "<a href=\"?action=view&page=$page\">$page</a>"
        } 
        return "<a href=\"?action=edit&page=$page\">$page</a>"
    }

    method not_found() {
        my $template = HTML::Template.new(
            filename => $.template_path ~ 'not_found.tmpl');

        $template.param('PAGE' => 'Action Not found');

        $.cgi.send_response(
            $template.output(),
        );
        return;
    }

    method log_in {

        if my $user_name = $.cgi.param<user_name> {

            my $password = $.cgi.param<password>;
            $*ERR.say("USER='$user_name'");
            $*ERR.say("PASS='$password'");

            my %users = self.read_users();

            if $password eq %users{$user_name}<plain_text> {
#            if Digest::MD5::md5_base64(
#                   Digest::MD5::md5_base64($user_name) ~ $password
#               ) eq %users{$user_name}<password> {

             if 1 {
                my $template = HTML::Template.new(
                    filename => $.template_path ~ 'login_succeeded.tmpl');

                my $session_id = get_unique_id();
                my $session_cookie = "session_id=$session_id";
                
                self.add_session( $session_id, { user_name => $user_name } );

                $.cgi.send_response(
                    $template.output(),
                    { cookie => $session_cookie }
                );

                return;
            }

            my $template = HTML::Template.new(
                filename => $.template_path ~ 'login_failed.tmpl');

            $.cgi.send_response(
                $template.output(),
            );

            return;
        }

        my $template = HTML::Template.new(
            filename => $.template_path ~ 'log_in.tmpl');

        $.cgi.send_response(
            $template.output(),
        );

        return;
    }

    method add_session( $id, %stuff) {
        my $sessions = self.read_sessions();
        $sessions{$id} = %stuff;
        self.write_sessions($sessions);
    }

    method read_sessions {
        return {} unless file_exists( $.sessionfile_path );
        my $string = slurp( $.sessionfile_path );
        my $stuff = eval( $string );
        return $stuff;
    }

    method remove_session($id) {
        my $sessions = self.read_sessions();
        # RAKUDO: No 'delete' builtin
        $sessions{$id} = 'DELETED';
        self.write_sessions($sessions);
    }

    method write_sessions( $sessions ) {
        my $fh = open($.sessionfile_path, :w);
        $fh.say($sessions.perl);
        $fh.close;
    }

    method log_out {

        if defined $.cgi.cookie('session_id') {
            my $template = HTML::Template.new(
                filename => $.template_path ~ 'logout_succeeded.tmpl');

            my $session_id = $.cgi.cookie('session_id');
            self.remove_session( $session_id );

            my $session_cookie = "session_id=''";

            $.cgi.send_response(
                $template.output(),
                { :cookie($session_cookie) }
            );

            return;
        }

        my $template = HTML::Template.new(
            filename => $.template_path ~ 'logout_succeeded.tmpl');

        $.cgi.send_response(
            $template.output(),
        );

        return;
    }

    sub file_exists( $file ) {
        # RAKUDO: use ~~ :e
        my $exists = False;
        try {
            my $fh = open( $file );
            $exists = True;
        }
        return $exists;
    }

    sub get_unique_id {
        # hopefully unique ID
        return int(time%1000000/100) ~ time%100
    }
}

grammar Wiki::Syntax {
    token TOP { ^ [ <paragraph> | <newlines> ]* $ };

    token paragraph { <parchunk>+ };
    token newlines { \n ** {2..*} };

    token parchunk { <twext> || <wikimark> || <metachar> || <malformed> };

    # RAKUDO: a token may not be called 'text' [perl #57864]
    token twext { [ <alnum> || <otherchar> || <sp> ]+ };

    # RAKUDO: sequences of quoted characters don't work [perl #57870
#    token otherchar { <[ '!'..'%' '('..'/' ':' ';' '?' '@'
#                      '\' '^'..'`' '{'..'~' ]> };
    token otherchar {
      [ '!' | '#' | '$' | '%' | '(' | ')' | '*' | '+'
      | ',' | '-' | '.' | '/' | ':' | ';' | '=' | '?'
      | '@' | '^' | '_' | '`' | '{' | '|' | '}' | '~'
      | '\\'
      ]
    };

    token sp { ' ' };

    token wikimark { '[[' <twext> ']]' };

    token metachar { '<' || '>' || '&' || \' };

    token malformed { '[' || ']' || <!after \n> \n <!before \n> }
}

my Wiki $wiki = Wiki.new;
$wiki.init();
my $cgi = CGI.new;
$cgi.init();
$wiki.handle_request($cgi);
